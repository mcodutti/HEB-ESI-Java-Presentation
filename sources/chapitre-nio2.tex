\section{Les entrées-sorties (NIO2)}
\leconwithtoc 

\subsection{Présentation}
\leconwithtocinside

\begin{frame}[fragile]{Présentation}
\emph{Préalable} Le \textit{package} NIO.2, comme présenté, concerne le JDK 7 (et suivants)
\end{frame}

\subsection{Notion de <<varargs>>}
\leconwithtocinside 

\begin{frame}[fragile]{Notion de <<varargs>>}
\emph{Principe} \textit{varargs} est un principe java permettant 
d'écrire des méthodes acceptant un nombre variable d'arguments

\bigskip Une même méthode \texttt{foo} peut-être appelée 
\begin{Java} 
foo("one");
foo("one","two");
String[] ss = {"one", "two", "three"};
foo(ss);
\end{Java} 

Pour ce faire, 
\begin{Java} 
public void foo(String... ss) { <enter code here> }
\end{Java} 

... et le paramètre reçu est un \textbf{simple tableau}
\end{frame}

\subsection{L'interface <<Path>>}
\leconwithtocinside 

\begin{frame}[fragile]{L'interface <<Path>>}
Un \emph{fichier} est identifié par son chemin à travers le \textit{filesystem}, 
on parle aussi de 
	\begin{itemize}
		\item son nom complètement qualifié (FQN - \textit{Fully Qualified Name}), 
		\item son \textit{\textbf{Path}} (qui signifie \textit{chemin})
	\end{itemize}
Par exemple 
	\begin{itemize}
		\item \texttt{/home/alice/java/Hello.java} ou 
		\item \verb|C:\Users\alice\java\Hello.java|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
Rappels
	\begin{itemize}
		\item le séparateur (\textit{delimiter}) est différent en fonction du \textit{filesystem}
		\item un chemin (\textit{path}) peut-être \textbf{relatif} ou \textbf{absolu}
		\item certains systèmes de fichiers autorisent la notion de \textbf{lien symbolique} 
		(\textit{symbolic link})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
L'interface \emph{\texttt{Path}} en java représente un 
chemin (\textit{path}) et permet de le manipuler
	\begin{itemize}
		\item créer un \textit{path}
		\item utiliser l'information contenue dans un \textit{path}
		\item convertir un \textit{path}
		\item comparer deux \textit{path}
		\item ...
	\end{itemize}
La classe \texttt{\emph{Paths}}
est une classe utilitaire permettant de créer un \textit{path} (une
\textit{Factory}) \\
\bigskip
\emph{Remarque}: Le fichier que le chemin représente peut ne pas exister
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
\begin{itemize}
\item Créer un \textit{path}
	\begin{Java}
	Path path1 = Paths.get("/tmp/foo");
	Path path2 = Paths.get(System.getProperty("user.home"),
	    "logs", "foo.log");
	\end{Java} 
\item Utiliser les informations contenues dans un \textit{path} \\
{\small (Soit la déclaration (dans un contexte linux))}
		\begin{Java} 
		Path path = Paths.get("/home/alice/foo");
		\end{Java} 
		\begin{itemize}
			\item \texttt{toString} $\longrightarrow$ /home/alice/foo
			\item \texttt{getFileName} $\longrightarrow$ foo
			\item \texttt{getParent} $\longrightarrow$ /home/alice
			\item \texttt{getRoot} $\longrightarrow$ /
		\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
\begin{itemize}
\item Convertir un \textit{path}
\begin{itemize}
\item \textbf{\texttt{toUri()}} \\ 
vers une uri (\textit{uniform resource identifier})
\begin{Java} 
Path path = Paths.get("/var/log/syslog");
System.out.println(path.toUri());
\end{Java} 
$\longrightarrow$ file:///var/log/syslog
\item \textbf{\texttt{toAbsolutePath()}} \\ 
vers un chemin absolu (si \texttt{pwd $\rightarrow$ /home/alice})
\begin{Java} 
Path path =  Paths.get("file");
System.out.println(path.toAbsolutePath());
\end{Java} 
$\longrightarrow$ /home/alice/file
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
\begin{itemize}
\item Convertir un \textit{path} (suite)
	\begin{itemize}
		\item \textbf{\texttt{toRealPath()}}  
		vers un chemin <<réel>>
		\begin{itemize}
			\item \textit{idem} que \texttt{toAbsolutePath()} mais 
			\item si c'est un \textbf{lien}, il est remplacé par le chemin vers
			lequel le lien pointe
		\end{itemize}
		\item \begin{Java} 	
Path path = Paths.get(args[0]);
Path fqnPath = null;
// ...
fqnPath = path.toRealPath();
// ...
System.out.println("Old path: " + path);
System.out.println("New path: " + fqnPath);
		\end{Java} 
		{\small (extrait de la classe \texttt{RealPath.java})}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
\begin{itemize}
	\item Convertir un \textit{path} (suite)
	\begin{itemize}
		\item \textbf{\texttt{toRealPath}} (suite)
		\begin{itemize}
		\item Soit la situation suivante
		\begin{Java} 
$ls -l /elsewhere
-rw-r--r-- 1   bob bob  592 Jan 13 16:56 file
lrwxrwxrwx 1   bob bob  13 Jan 13 16:57 link -> file
		\end{Java} 
		\item \texttt{java RealPath file} $\longrightarrow$ /elsewhere/file
		\item \texttt{java RealPath /elsewhere/file} $\longrightarrow$ /eslewhere/file
		\item \texttt{java RealPath link} $\longrightarrow$ /elsewhere/file
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
\begin{itemize}
\item Convertir un \textit{path} (suite)
\begin{itemize}
\item \textbf{\texttt{resolve(Path)}} \\
permet de créer un chemin sur base de deux chemins incomplets
\begin{Java} 
Path path;
path = Paths.get(".").toRealPath();
System.err.println("Error: " + e.getMessage());
System.exit(1);
}
System.out.println("Path: " + path);		
System.out.println("Path: " + path.resolve("file"));			
\end{Java} 
\texttt{java ResolvePath} $\longrightarrow$  \\ 
    Path: /elsewhere \\ 
    Path: /elsewhere/file
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{L'interface <<Path>>}
\begin{itemize}
\item ... et finalement la classe \texttt{Path}
\begin{itemize}
\item impose une méthode \texttt{equals(Object)}
\item ajoute des méthodes
	\begin{itemize}
	\item \texttt{startWidth(Path)} et \texttt{startWidth(String)}
	\item \texttt{endsWidth(Path)} et \texttt{endsWidth(String)}
	\item \texttt{isSameFile()} (voir plus loin, la classe \texttt{Files})
	\end{itemize}
\item implémente \texttt{Iterable}
\item implémente \texttt{Comparable}
\end{itemize}
\end{itemize}
\end{frame}

\subsection{Opérations sur les fichiers, la classe <<Files>>}
\leconwithtocinside 

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
La classe \emph{\texttt{Files}} est la deuxième classe utilitaire importante du
\textit{package} NIO.2

Vérifier (\textit{checking}) un fichier ou un répertoire
	\begin{itemize}
	\item \textbf{\texttt{exists(Path, LinkOption\dots)}} teste l'existence
	\begin{Java} 
	Files.exists(path);
	Files.exists(path, LinkOption.NOFOLLOW_LINKS));
	\end{Java}
	\item \textbf{\texttt{notExists(Path, LinkOption\dots)}} teste la non-existence 
	\begin{Java} 
	Files.notExists(path);
	\end{Java} 
	\item Ces deux méthodes ne sont pas complémentaires ... 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
Vérifier (\textit{checking}) un fichier ou un répertoire (suite)
\begin{itemize}
	\item \textbf{\texttt{isReadable(Path)}} vérifie si le fichier est accessible en lecture
	\item \textbf{\texttt{isWritable(Path)}} vérifie si le fichier est accessible en écriture
	\item \textbf{\texttt{isExecutable(Path)}} vérifie si le fichier est accessible en exécution
	\item \textbf{\texttt{isSameFile(Path, Path)}} vérifie si les deux chemins 
	renseignent le même fichier
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
Effacer (\textit{delete}) un fichier ou un répertoire vide
\begin{itemize}
	\item \textbf{\texttt{delete(Path)}} \\
	lance une exception si le fichier/répertoire n'existe pas
	\item \textbf{\texttt{deleteIfExists(Path)}}
\end{itemize}
\begin{Java} 
try {
    Files.delete(path);
} catch (NoSuchFileException x) {
    System.err.format("%s: no such" +
        " file or directory%n", path);
} catch (DirectoryNotEmptyException x) {
    System.err.format("%s not empty%n", path);
} catch (IOException x) {
    // File permission problems are caught here.
    System.err.println(x);
}
\end{Java} 
\end{frame}

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
Copier un fichier ou un répertoire
	\begin{itemize}
		\item \textbf{\texttt{copy(Path, Path, CopyOption\dots)}}
		\begin{itemize}
		\item Sans \textit{replace existing}, la copie échoue si le fichier existe
		\item Copier un répertoire vers un autre ne copie que le répertoire
		\textbf{pas son contenu}
		\end{itemize}
		\item Copie de fichiers ou de répertoires
\begin{Java} 
Files.copy(source, target);
Files.copy(source, target, CopyOption.REPLACE_EXISTING);
\end{Java} 
		\item Il existe deux méthodes permettant de copier de/vers un 
		\textbf{autre type de flux}
		\begin{itemize}
			\item \texttt{copy(InputStream, Path, CopyOption\dots)}
			\item \texttt{copy(Path, OutputStream)}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
Déplacer un fichier ou un répertoire
	\begin{itemize}
		\item \textbf{\texttt{move(Path, Path, CopyOption\dots)}}
		\begin{itemize}
			\item \textit{idem} \texttt{copy}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
Obtenir les métadonnées d'un fichier \\
(quelques méthodes en vrac) \\ 
\begin{center}\tt
size(Path) isHidden(Path)  isDirectory(Path) isRegularFile(Path)
isSymbolicLink(Path) getLastModifiedTime(Path, LinkOption...)
setLastModifiedTime(Path, \textit{FileTime})  \\  getOwner(Path, LinkOption...)
\\ setOwner(Path, \textit{UserPrincipal}) ...
\end{center}
\end{frame}

\begin{frame}[fragile]{Opérations sur les fichiers, la classe <<Files>>}
Obtenir les métadonnées d'un fichier (suite)
	\begin{itemize}
		\item \texttt{FileTime} représente un temps associé à un fichier. 
		Par exemple, un \textit{timestamp} dans une heure
\begin{Java} 
FileTime ft = FileTime.fromMillis(
    System.currentTimeMillis() 
       + (1000*60*60));
\end{Java} 
		\item La valeur de \texttt{UserPrincipal} est obtenue grâce au 
		\textit{user lookup service} comme suit
\begin{Java} 
UserPrincipal owner = FileSystems.getDefault()
    .getUserPrincipalLookupService()
    .lookupPrincipalByName("alice");
\end{Java} 
		{\small La classe \emph{\texttt{FileSystems}} est une classe utilitaire de
		NIO.2}
	\end{itemize}
\end{frame}

\subsection{Où l'on reparle de lire / écrire des fichiers}
\leconwithtocinside 

\begin{frame}[fragile]{Où l'on reparle de lire / écrire des fichiers}
Lire un fichier
\begin{itemize}
\item \textbf{Rappel} Pour lire un fichier, on faisait:
\begin{Java} 
try {
    BufferedReader reader = new BufferedReader(
        new FileReader("input.txt"));
    // lire 
    reader.close();
catch (IOException x) {
    // Gérer les erreurs
   if (reader != null) {
      try {
          reader.close();
      } catch (IOException x2) {
           // Plus rien à faire
      }
   }
}
\end{Java} 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Où l'on reparle de lire / écrire des fichiers}
Lire un fichier (suite)
	\begin{itemize}
		\item La classe \texttt{\emph{Files}} propose une méthode  \\ 
		\hspace{1cm}\texttt{newBufferedReader(Path, Charset)}
		\begin{itemize}
			\item plus efficace
			\item \texttt{Closeable}
		\end{itemize}
		\bigskip
		\item C'est une \textbf{bonne pratique d'utiliser le \textit{try-with-resources}} car alors le compilateur génère automatiquement le code permettant de fermer (\textit{close}) lesdites ressources (celles qui sont \texttt{Closeable})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Où l'on reparle de lire / écrire des fichiers}
Lire un fichier (suite)
\begin{Java} 
// ...
Charset charset = Charset.forName("UTF-8");
Path file = Paths.get(args[0]);
try (BufferedReader reader = Files.newBufferedReader(file, charset)){
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
    System.exit(1);
}
\end{Java} 
\end{frame}

\begin{frame}[fragile]{Où l'on reparle de lire / écrire des fichiers}
Écrire un fichier
\begin{itemize}
\item De même, la classe \texttt{\emph{Files}} propose une méthode  \\ 
\hspace{1cm}\texttt{newBufferedWriter(Path, Charset)}
\end{itemize}
\begin{Java} 
// ...
Charset charset = Charset.forName("UTF-8");
Path file = Paths.get(args[0]);
String s = "Hello world\n";
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)){
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
\end{Java} 
\end{frame}


\begin{frame}[fragile]{Où l'on reparle de lire / écrire des fichiers}
D'autres méthodes encore de la classe \texttt{\emph{Files}}
	\begin{itemize}
		\item \texttt{newInputStream(Path, OpenOption...)} retournant un
		\texttt{InputStream}
		\item \texttt{newOutputStream(Path, OpenOption...)} retournant un
		\texttt{OutputStream}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Où l'on reparle de lire / écrire des fichiers}
D'autres méthodes encore de la classe \texttt{\emph{Files}} (suite)
	\begin{itemize}
		\item \texttt{createTempFile(String, String)} pour créer un \textbf{fichier temporaire}
\begin{Java} 
try {
    Path tempFile =
        Files.createTempFile(null, ".myapp");
    System.out.format("The temporary file" 
        + " has been created: %s%n", tempFile);
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
\end{Java} 
$\longrightarrow$ The temporary file has been created: /tmp/8614889884323775294.myapp
	\end{itemize}
\end{frame}

\subsection{Déterminer le MIME type d'un fichier}
\leconwithtocinside 

\begin{frame}[fragile]{Déterminer le MIME type d'un fichier}
Déterminer le MIME type d'un fichier
\begin{itemize}
\item \texttt{probeContentType(Path)} permet d'obtenir le MIME type d'un fichier
\end{itemize}
\begin{Java} 
// ...
try {			 
    path = Paths.get(args[0]).toRealPath();
    String mimetype = Files.probeContentType(path);
    System.out.format("%s mimetype is %s\n", 
        path.getFileName(), 
        mimetype);
} catch (IOException x) {
    System.err.println(x);
    System.exit(1);
}
\end{Java} 
\end{frame}

\subsection{Au sujet des exceptions}
\leconwithtocinside 

\begin{frame}[fragile]{Au sujet des exceptions}
\begin{itemize}
	\item La plupart des méthodes retournent une \texttt{IOException}
	\begin{itemize}
		\item \texttt{java.io.Exception}
	\end{itemize}
	\bigskip
	\item La classe \texttt{\emph{FileSystemException}} est une 
	\texttt{IOException} offrant plus d'informations sur l'exception
	\begin{itemize}
		\item \texttt{java.nio.file.FileSystemException}
		\item \texttt{getReason}, \texttt{getFile}, \texttt{getMessage}, \texttt{getOtherFile}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Au sujet des exceptions}
\begin{itemize}
	\item Il pourrait être intéressant d'écrire (par exemple) ...
\begin{Java} 
try {			 
    // ...
} catch (FileSystemException x) {
    System.err.format("%s - %s - %s\n",  x.getFile(), 
        x.getReason(), x.getMessage());
    System.exit(1);
} catch (IOException x) {
    System.err.println(x);
    System.exit(1);
}
\end{Java} 
\end{itemize}
\end{frame}

\subsection{Concepts NIO.2 non abordés}
\leconwithtocinside 

\begin{frame}[fragile]{Concepts NIO.2 non abordés}
Concepts NIO.2 non abordés
	\begin{itemize}
	\item L'accès non séquentiel aux fichiers 
	\href{http://docs.oracle.com/javase/tutorial/essential/io/rafs.html}{[lien]}
	\item La gestion des répertoires; création, parcours, ....
	\href{http://docs.oracle.com/javase/tutorial/essential/io/dirs.html}{[lien]}
	\item L'utilisation des \textit{hard links} par rapport aux \textit{soft links}
	\item Parcours du système de fichiers 
	\href{http://docs.oracle.com/javase/tutorial/essential/io/walk.html}{[lien]}
	\item Recherche de fichiers, utilisation de \textit{wildcards} ou d'expression régulière (\textit{regex})
	\item Surveillance de répertoires
	\end{itemize}
\end{frame}

