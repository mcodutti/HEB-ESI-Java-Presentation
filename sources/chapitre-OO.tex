%=== Cours de Java
%=== Chapitre : OO

\section{L'orient� objet}

\begin{frame}
\begin{block}{\center Le�on \thesection\ ---   \insertsection}
  {
  \begin{multicols}{2}
  \tableofcontents[sectionstyle=hide,subsectionstyle=show/show/hide]
  \end{multicols}
  \bigskip
  }
\end{block}
\end{frame}

\begin{frame}{Avertissement}
Pour qu'un langage soit \textit{orient� objet} il doit poss�der 3 propri�t�s
  \begin{itemize}
  \item L' \emph{encapsulation}
  \item L' \emph{h�ritage}
  \item Le \emph{polymorphisme}
  \end{itemize} 
\bigskip
Trop pour le cours de 1�re ann�e
  \begin{itemize}
  \item Nous allons surtout voir l'encapsulation \\(comme au cours de logique)
  \item Et effleurer le reste $\longrightarrow$ parfois impr�cis
  \end{itemize}
\end{frame}

\begin{frame}{Rappels}
Voici ce que vous avez d�j� vu en logique
\begin{center}
\includegraphics[scale=.6]{../img/oo-rappels}
\end{center}
\end{frame}

\begin{frame}{Pr�sentation de l'exemple}
Illustrons ces concepts avec la notion d'\textit{�tudiant � l'ESI}
\begin{itemize}
 \item Un �tudiant
    \begin{itemize}
    \item poss�de un nom et un num�ro unique
    \item est inscrit dans une ann�e d'�tude
    \item est doubleur ou pas
    \item est un \textit{ancien} (a termin�) ou pas
    \end{itemize}
  \item Il peut r�ussir son ann�e ou la rater
  \end{itemize}
\end{frame}

\subsection{La classe}

\begin{frame}{La classe}
  \emph{Exemple}: Repr�sentation graphique (UML) de la classe \textit{Etudiant}
  \begin{center}
  \begin{tabular}{cl}
    {\small\fcolorbox{black}{bleu}{
      \begin{tabular}{l}
        ~~~~~~~~~Etudiant\\ 
        \hline
        - num�ro : Entier\\
        - nom : Chaine\\
        - ann�e�tude : Entier\\
        - doubleur : Bool�en\\
        - ancien : Bool�en\\
        \hline
        + aR�ussi()\\
        + aRat�()\\
      \end{tabular}
    }} &
    {\small
      \begin{tabular}{l}
        \textbf{Nom de la classe} \\ 
        \textbf{Attributs} \\
        Le "-" indique qu'ils sont \textbf{priv�s}\\
        Connus uniquement dans la classe\\
        En \sigle{Java} on �crira \java|private|\\
        \\
        \textbf{M�thodes}\\
        Le "+" car elles sont \textbf{publiques}\\
        En \sigle{Java} on �crira \java|public|\\
      \end{tabular}
    } \\
  \end{tabular}
  \end{center}
\end{frame}

\subsection{Les objets}

\begin{frame}{Les objets}
  \emph{Exemple} : Repr�sentation graphique de 2 objets (instances) possibles :
  \medskip
  \begin{center}
  \begin{tabular}{cc}
  {\small\fcolorbox{black}{bleu}{
    \begin{tabular}{l}
      \underline{James Gosling}: Etudiant\\ 
      \hline
      - num�ro = 34000\\
      - nom = "James Gosling"\\
      - ann�e�tude = 1\\
      - doubleur = faux\\
      - ancien = faux\\
      \hline
      + aR�ussi()\\
      + aRat�()\\
    \end{tabular}
  }} &
  {\small\fcolorbox{black}{bleu}{
    \begin{tabular}{l}
      \underline{Ada Lovelace}: Etudiant\\ 
      \hline
      - num�ro = 33800\\
      - nom = "Ada Lovelace"\\
      - ann�e�tude = 2\\
      - doubleur = faux\\
      - ancien = faux\\
      \hline
      + aR�ussi()\\
      + aRat�()\\
    \end{tabular}
  }} \\
  \end{tabular}
  \end{center}
\end{frame}

\subsection{Les membres}

\begin{frame}{Les membres}
Chaque instance poss�de les m�mes attributs mais avec des \emph{valeurs diff�rentes}
\\\bigskip
Les m�thodes d'une instance agissent sur les attributs de cette instance 
  \begin{itemize}
   \item La m�thode \textit{aRat�()} d'un �tudiant va mettre \emph{son} attribut \textit{doubleur} � vrai
   \item Que ferait la m�thode \textit{aR�ussi()} ?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{La classe en Java}
  � ce stade la classe \texttt{Etudiant} peut s'�crire :
  \begin{multicols}{2}  
  \begin{Java}
  public class Etudiant {

    private int num�ro; 
    private String nom;
    private int ann�e�tude;
    private boolean doubleur;
    private boolean ancien; 

    public void aRat�() {
      doubleur = true;
    }
  \end{Java}
  \begin{Java}

    public void aR�ussi() {
      doubleur = false;
      ann�e�tude++;
      if (ann�e�tude == 4 ) {
        ancien = true;
      }
    }

  }  
  \end{Java}
  \end{multicols}
\begin{itemize}
\item Remarquez l'absence de \java{static} pour les m�thodes
\end{itemize}
\end{frame}

\begin{frame}{OO or not OO ?}
On utilisait d�j� \java|class|. On faisait de l'objet ?
\\\bigskip
Oui et non ;)
\begin{itemize}
\item \sigle{Java} est un langage orient� objet
\item Mais il permet une �criture non OO
\item Via l'utilisation de \java|static|
(qui a un sens plus large que nous d�taillerons plus loin)
\end{itemize}
\end{frame}

\begin{frame}{OO or not OO ?}
En gros, on a 2 sortes de classes : 
\\\bigskip
\begin{small}
\begin{tabular}{l|l|l}
\hline\hline
& {\small \emph{approche non OO}} & {\small \emph{approche OO}} \\\hline
But & regrouper des m�thodes & d�finir un type de donn�es \\
Attribut & non (sauf constantes) & oui \\
Instances & non & oui \\
Utilisation via & le nom de la classe & une instance \\
\java|static| & oui & non \\
Fr�quence & rare & fr�quent \\
Exemples & \java|Math| & \java|String|, \java|Scanner| \\
\hline\hline
\end{tabular}
\end{small}
\\\bigskip
\textit{En pratique, on rencontrera des situations mixtes}
\end{frame}

\begin{frame}{Visibilit� des membres}
En \sigle{Java} : 4 visibilit�s
\begin{description}
  \item[public] : visible dans \textbf{toutes} les classes (\java|public|)
  \item[priv�] : n'est accessible que de \textbf{la} classe (\java|private|)
  \item[<<paquet�>>] : visible dans toutes les classes du \textit{package} (pas de mot cl�)
  \item[prot�g�] : pas vu en 1�re ann�e (\java|protected|)
\end{description}
\bigskip
Rappel \emph{bonne pratique} :
\\attributs priv�s / m�thodes publiques
\end{frame}

\subsection{Constructeur}

\begin{frame}[fragile]{Constructeur}
\emph{Exemple} : D�finition d'un constructeur
  \begin{Java}
  public Etudiant (int unNum�ro, String unNom) {
    num�ro = unNum�ro;
    nom = unNom;
    ann�e�tude = 1;
    doubleur = false;
    ancien = false;
  }
  \end{Java}
  Ressemble � une m�thode mais
  \begin{itemize}
    \item Pas de type de retour d�clar�
%    \item En pratique, retourne la r�f�rence de l'objet 
    \item A le m�me nom que celui de la classe
  \end{itemize}
\end{frame}

\subsection{Instanciation}

\begin{frame}[fragile]{Instanciation}
Pour instancier 
\begin{itemize}
\item On utilise l'op�rateur \java|new|
\item On fournit les param�tres au constructeur
\end{itemize}
\medskip
\emph{Exemple} : instanciation d'un �tudiant
\begin{itemize}
\item[]
\begin{Java}
Etudiant ada = new Etudiant(33800, "Ada Lovelace");
\end{Java}
\item Cr�e un nouvel objet \java|Etudiant|
\item Appelle le constructeur pour l'initialiser
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Instanciation}
Une classe est un type \emph{r�f�rence} (comme les tableaux)
\medskip
\\\emph{Exemple} :
\begin{Java}
    Etudiant ada;  // r�f�rence cr��e sur la pile
\end{Java}
\vspace{-10pt}
\begin{center}\includegraphics[scale=.4]{../img/java-oo-alloc1}\end{center}
\begin{Java}
    ada = new Etudiant(33800,"Ada Lovelace"); // objet cr�� sur le tas
\end{Java}
\vspace{-10pt}
\begin{center}\includegraphics[scale=.5]{../img/java-oo-alloc2}\end{center}
\end{frame}

\begin{frame}[fragile]{Appel d'une m�thode}
Utilisation de la notation \textit{point�e} (op�rateur \code{.})
\\\bigskip
\emph{Exemple}
\begin{Java}
public static void main(String[] args) {
    Etudiant ada = new Etudiant(33800, "Ada Lovelace");
    ada.aR�ussi();
}
\end{Java}
\bigskip
Code que l'on peut trouver
\begin{itemize}
\item dans une autre classe
\item dans la classe m�me
\end{itemize}
\end{frame}

\subsection{Accesseurs}

\begin{frame}[fragile]{Accesseurs}
\emph{Accesseur} : m�thode donnant la valeur d'un attribut 
\\\bigskip
\emph{Exemple} : pour notre classe �tudiant
\begin{Java}
  public int getNum�ro() {return num�ro;}
  public String getNom() {return nom;}
  public int getAnn�e�tude() {return ann�e�tude;}
  public boolean isDoubleur() {return doubleur;}
  public boolean isAncien() {return ancien;}
\end{Java}
\bigskip
Par convention, l'accesseur de \java|attribut| est \java|getAttribut| 
(\java|isAttribut| pour un bool�en)
\end{frame}

\begin{frame}[fragile]{Appel d'une m�thode}
\emph{Exemple} : Utilisation des accesseurs
\begin{Java}
public static void main(String[] args) {
    Etudiant ada = new Etudiant(33800, "Ada Lovelace");
    System.out.println(ada.getAnn�e�tude()); // 1
    ada.aR�ussi();
    System.out.println(ada.getAnn�e�tude()); // 2
    System.out.println(ada.isDoubleur()); // false
    ada.aRat�();
    System.out.println(ada.getAnn�e�tude()); // 2
    System.out.println(ada.isDoubleur()); // true
}
\end{Java}
\end{frame}

\subsection{Mutateurs}

\begin{frame}[fragile]{Mutateurs}
\emph{Mutateur} : sert � modifier un attribut 
\\\bigskip
\emph{Exemple} : un mutateur possible pour \textit{Etudiant}
\begin{Java}
  public void setNom(String unNom) {nom = unNom;}
\end{Java}
\bigskip
Par convention, le mutateur de \java|attribut| est \java|setAttribut|
\\\bigskip
\emph{Exemple} : Appel d'un mutateur
\begin{Java}
  Etudiant ada = new Etudiant(33800,"Ada Lovelace");
  System.out.println( ada.getNom() );
  ada.setNom("James Gosling");
  System.out.println( ada.getNom() );
\end{Java}
\end{frame}

\begin{frame}{Mutateurs}
\emph{Bonne pratique} : 
\\Bien r�fl�chir avant de fournir un mutateur
\begin{itemize} 
\item Est-ce que le num�ro peut changer ? Non !
\item Est-ce que le nom peut changer ? Euh !
\item Est-ce que l'ann�e peut changer ? Oui ! 
  \begin{itemize} 
  \item Mais est-ce qu'il faut permettre de la changer directement ?
  \item ou uniquement via des m�thodes comme \java|aR�ussi()| ? 
  \\� voir au cas par cas
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tests de validit�}
Il est conseill� d'effectuer des \emph{tests de validit�} sur les param�tres
\begin{itemize}
\item Constructeur : objet cr�� dans un �tat valide
\item Mutateur : l'�tat reste valide
\end{itemize}
\emph{Exemple} :
\begin{Java}
  public void setNum�ro(int unNum�ro) {
    if (unNum�ro<=0) {
      throw new IllegalArgumentException("Le num�ro est n�gatif !");
    }
    num�ro = unNum�ro;
  }
\end{Java}
\end{frame}

%\begin{frame}[fragile]{Tests de validit�}
%\emph{Bonne pratique} :
%\\Appeler les mutateurs dans le constructeur
%\begin{itemize} 
%  \item On �vite ainsi de dupliquer les tests
%  \item Exemple
%\begin{Java}
%  public Etudiant (int unNum�ro, String unNom) {
%    setnum�ro(unNum�ro);
%    // la suite...
%}
%\end{Java}
%\item Et si un test est n�cessaire mais qu'on ne veut pas offrir de mutateur ? D�finir le mutateur en priv�
%\end{itemize}
%\end{frame}

\subsection{Surcharge}

\begin{frame}{Surcharge}
\emph{Surcharge} (overloading) : possibilit� de d�finir plusieurs m�thodes/constructeurs
\begin{itemize}
\item De m�me nom
\item Si signatures diff�rentes
\item Facilit� pour l'utilisateur
\end{itemize}
\bigskip
Tr�s utile pour les constructeurs
\begin{itemize}
\item Plusieurs fa�ons d'initialiser l'�tat
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Surcharge}
\emph{Exemple} : Constructeurs pour \texttt{Etudiant}
\begin{Java}
  public Etudiant (int unNum�ro, String unNom) {
    num�ro = unNum�ro;
    nom = unNom;
    ann�e�tude = 1;
    doubleur = false;
    ancien = false;
  }

  public Etudiant (int unNum�ro, String unNom, int ann�e, 
                   boolean doubl, boolean anc) {
    num�ro = unNum�ro;
    nom = unNom;
    ann�e�tude = ann�e;
    doubleur = doubl;
    ancien = anc;
  }
\end{Java}
\end{frame}

\subsection{this}

\begin{frame}[fragile]{this()}
Souvent, les constructeurs d'une m�me classe se ressemblent
  \begin{itemize}
  \item Cf. exemple pr�c�dent
  \item Plus facile si un constructeur appelle l'autre
  \item On utilise la notation \java|this()|
  \item Exemple
  \begin{Java}
  public Etudiant (int num�ro, String nom) {
    this(num�ro, nom, 1, false, false);
  }
  \end{Java}
  \item Doit �tre la \emph{premi�re instruction}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Le mot cl� <<this>>}
Le mot cl� \java{this} est une r�f�rence � soi-m�me 
\begin{itemize}
\item Implicite lors d'une utilisation directe du membre
\item \emph{Exemple}
  \begin{Java}
  public void setNom( String unNom ) {
    nom = unNom;  // implicitement: this.nom = unNom;
  }

  public void aR�ussi() {
    f�liciter(); // implicitement : this.f�liciter();
    // ...
  }

  public void f�liciter() {
    // ...
  }
  \end{Java}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Le mot cl� <<this>>}
R�gle : un param�tre/une variable locale \emph{masque} un attribut
  \begin{itemize}
  \item \java|this| permet d'acc�der � l'attribut masqu� 
  \item \emph{Exemple}
  \begin{Java}
  public void setNom( String nom ) {
    this.nom = nom;
  }
  \end{Java}
  \item Certains l'utilisent syst�matiquement pour une meilleure lisibilit�
  \end{itemize}
\end{frame}

\subsection{static}

\begin{frame}{Comprendre <<static>>}
  \emph{\java{static}} s'applique aux membres (attributs + m�thodes)
  \begin{itemize}
    \item N'est plus un membre de l'objet (instance de la classe) mais un membre de la classe
    \item Est \emph{partag�} par toutes les instances
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Comprendre <<static>>}
  \emph{Attribut} statique
  \begin{itemize}
    \item Existe en un seul exemplaire 
    \item Est initialis� lors du chargement de la classe \\(une seule fois)
    \item Utilisation courante : constantes
  \\\emph{Exemple}
  \begin{Java}
  public class Math { 
    public static final double PI = 3.14159265358979323846;
    public static final double E = 2.7182818284590452354;
  }
  \end{Java}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Comprendre <<static>>}
  \emph{M�thode} statique
  \begin{itemize}
    \item Ne peut pas acc�der aux membres des instances
    \item Utilisation courante : m�thodes non objets
  \\\emph{Exemple}
  \begin{Java}
  public class Outils {
    public static int abs(int nb) {
      return nb < 0 ? -nb : nb;
    }
  }
  \end{Java}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Comprendre <<static>>}
  � l'ext�rieur de la classe, 
  \begin{itemize}
  \item on pr�fixe par le nom de la classe
  \begin{Java}
  int abs = Outils.abs(-3);
  double un = Math.log (Math.E);
  \end{Java}
  \item ou un objet de la classe (non recommand�)
  \begin{Java}
  Outils outil = new Outils();
  int lg = outil.abs(-3);
  \end{Java}
  Pourquoi peut-on cr�er un \code{outil} ?
 
  Comment l'emp�cher ?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Comprendre <<static>>}
  \java{import static} cr�e un raccourci pour l'acc�s aux membres statiques 
  \\\medskip\emph{Exemple}
  \begin{Java}
  import static java.lang.Math.log;
  import static java.lang.Math.E;
  public class Test {
    public static void main( String[] args ) {
      System.out.println( log(E) );
    }
  }
  \end{Java}
  \medskip\emph{Exemple}
  \begin{Java}
  import static org.junit.Assert.*;
  \end{Java}
\end{frame}

\begin{frame}[fragile]{Un mot sur les structures}
En Logique, vous avez vu le concept de structure
\begin{itemize}
\item On peut imiter cette construction
\item \emph{Exemple} : une structure Adresse
\vspace{-0.5cm}
\begin{multicols}{2}
\begin{Code}
structure Adresse compos�e de
    rue : chaine
    num�ro : chaine
    code : entier
   localit� : chaine
fin structure
\end{Code}
\begin{Java}
public class Adresse {
    public String rue;
    public String num�ro;
    public int    code;
    public String localit�;
}
\end{Java}
\end{multicols}
\vspace{-0.5cm}
\item Mais, on pr�f�re une classe normale qui permet de contr�ler la valeur des champs
\end{itemize}
\end{frame}

\begin{frame}{Pr�cision sur l'instanciation}
Attributs initialis�s � une \emph{valeur par d�faut} \\(comme pour les tableaux)
  \begin{itemize}
  \item Num�rique : \java|0|
  \item Bool�en : \java|false|
  \item r�f�rence : \java|null| (r�f�rence vers \emph{rien})
  \end{itemize}
\bigskip
Rarement ce qui est souhait�
  \\$\longrightarrow$ toujours donner des valeurs explicites
\end{frame}

\begin{frame}{Pr�cision sur les constructeurs}
Il existe un \emph{constructeur par d�faut}
\begin{itemize}
  \item sans param�tre 
  \item ne fait rien
  \item uniquement \emph{si pas de constructeur explicite}
  \item Rarement une bonne id�e 
\end{itemize}
$\longrightarrow$ toujours �crire explicitement un constructeur
\end{frame}

\subsection{Des objets comme attributs}

\begin{frame}[fragile]{Des objets comme attributs}
Une classe d�finit un type � part enti�re 
\\$\longrightarrow$ peut �tre attribut d'une autre classe
  \begin{itemize}
  \item \emph{Ex} : \texttt{String} pour le nom d'un �tudiant
  \item \emph{Ex} : \texttt{Date} (de naissance) d'un �tudiant
  \end{itemize}
\bigskip
\pause
\emph{Exemple} : D�finissons le concept d'adresse
\begin{Java}[basicstyle=\scriptsize]
public class Adresse {
  private String rue;
  private String num�ro;
  private int codePostal;
  private String localit�;
  
  public Adresse (String uneRue, String unNum�ro, 
          int unCodePostal, String uneLocalit�) {
    // ...
  }
  // + accesseurs 
  // pas de mutateur ! Pourquoi ?
}
\end{Java}
\end{frame}

\begin{frame}[fragile]{Des objets comme attributs}
\emph{Exemple} : Ajoutons une adresse � un �tudiant
\begin{Java}
public class Etudiant {
  private Adresse adresse;
  
  public Etudiant (int unNum�ro, String unNom, Adresse uneAdresse) {
    adresse = uneAdresse;
    // ...
  }

  public Adresse getAdresse() {return adresse;}

  public void setAdresse(Adresse uneAdresse) {
    adresse = uneAdresse;
  }
  // ... 
}
\end{Java}
\end{frame}

\begin{frame}[fragile]{Des objets comme attributs}
\emph{Exemple} : Cr�ons un �tudiant
\begin{Java}
 Adresse adresse = new Adresse("Rue Royale", "67", 1000, "Bruxelles");
 Etudiant james = new Etudiant( 34000, "James Gosling", adresse );
\end{Java}
ou, en condens�
\begin{Java}
  Etudiant james = new Etudiant ( 
                       34000, "James Gosling", 
                       new Adresse("Rue Royale", "67", 1000, "Bruxelles") 
           );
\end{Java}
\end{frame}

\subsection{Objets et tableaux}

\begin{frame}[fragile]{Des tableaux d'objets}
Une classe d�finit un type de donn�es 
\\$\longrightarrow$ on peut d�finir des tableaux d'objets
\\\bigskip
\emph{Exemple} : un tableau d'�tudiants \java|Etudiant[]|
\begin{Java}
// Affiche un tableau d'�tudiants
public static void afficher(Etudiant[] �tudiants) {
    System.out.println("Il y a " + �tudiants.length + " �tudiants");
    for( Etudiant �tudiant : �tudiants ) {
        System.out.print( �tudiant.getNum�ro() 
                 + ", " + �tudiant.getNom() 
                 + ", " + �tudiant.getAnn�e�tude() 
                 );
    }
}
\end{Java}
\end{frame}

\begin{frame}[fragile]{Des tableaux d'objets}
\begin{Java}
// Faire r�ussir tous les �tudiants
public static void tourn�eG�n�rale(Etudiant[] �tudiants) {
    // Faire un sch�ma pour comprendre que le foreach est correct
    for( Etudiant �tudiant : �tudiants ) {
        �tudiant.aR�ussi();
    }
}
\end{Java}
\begin{Java}
  // Test
  Etudiant[] groupe11 = {
      new Etudiant(20000, "Tintin"),
      new Etudiant(20001, "Milou"),
      new Etudiant(20002, "Professeur Tournesol"),
      new Etudiant(20003, "Capitaine Haddock")
  };
  afficher(groupe11);
  tourn�eG�n�rale(groupe11);
  afficher(groupe11);
\end{Java}
\end{frame}

\begin{frame}{Des tableaux \textbf{dans} les objets}
Un tableau d�finit un type de donn�es
\\$\longrightarrow$ on peut le trouver comme attribut
\\\bigskip
\emph{Exemple} : D�finissons, la classe Groupe (d'�tudiants)
\begin{itemize}
\item La taille (maximale) du groupe sera donn�e � la construction
\item Une m�thode permet d'ajouter un �tudiant au groupe
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Des tableaux \textbf{dans} les objets}
\begin{Java}[basicstyle=\scriptsize]
public class Groupe {
    private Etudiant[] �tudiants;
    private int nbEtudiants;

    public Groupe(int taille) {
        if (taille < 1)
          throw new IllegalArgumentException("Pas de groupe vide");
        �tudiants = new Etudiant[taille]; // Faire un sch�ma !
        nbEtudiants = 0;
    } 

    public void ajouter(Etudiant �tudiant) {
        if (nbEtudiants == �tudiants.length)
          throw new IllegalStateException("Plus de place !");
        �tudiants[nbEtudiants] = �tudiant;
        nbEtudiants++;
    }

    // ...
\end{Java}
\end{frame}

\begin{frame}[fragile]{Des tableaux \textbf{dans} les objets}
\begin{Java}[basicstyle=\scriptsize]
    public void afficher() {
        System.out.println("Il y a " + nbEtudiants + " �tudiants");
        // Pourquoi pas un foreach ?
        for( int i=0; i<nbEtudiants; i++ ) {
            System.out.print( �tudiants[i].getNum�ro() 
                     + ", " + �tudiants[i].getNom() 
                     + ", " + �tudiants[i].getAnn�e() 
                     );
        }
    }
    // On pourrait encore d�finir beaucoup de m�thodes utiles
}
\end{Java}
\begin{Java}[basicstyle=\scriptsize]
  // Test
  Groupe groupe11 = new Groupe(10);
  groupe11.ajouter(new Etudiant(20000, "Tintin"));
  groupe11.ajouter(new Etudiant(20001, "Milou"));
  groupe11.ajouter(new Etudiant(20002, "Professeur Tournesol"));
  groupe11.ajouter(new Etudiant(20003, "Capitaine Haddock"));
  groupe11.afficher();
\end{Java}
\end{frame}

\begin{frame}{Rappel}
Pour qu'un langage soit \textit{orient� objet} il doit poss�der 3 propri�t�s
  \begin{itemize}
  \item L' \emph{encapsulation}
  \item L' \emph{h�ritage}
  \item Le \emph{polymorphisme}
  \end{itemize} 
\bigskip
Nous avons vu l'encapsulation; survolons le reste
\end{frame}

\begin{frame}{H�ritage}
\emph{H�ritage} : Permet de d�finir une classe � partir d'une autre
\begin{itemize}
\item Un peu comme du \textit{copier-coller}
\item On r�cup�re ainsi tous les attributs et toutes les m�thodes
\item Terminologie
  \begin{itemize}
  \item Classe \emph{parent} : celle dont on h�rite
  \item Classe \emph{enfant} : celle qui h�rite
  \end{itemize} 
\end{itemize} 
\end{frame}

\subsection{H�ritage}

\begin{frame}{H�ritage}
\begin{itemize}
\item Graphiquement, on le note ainsi
\begin{center}
\includegraphics[scale=.5]{../img/oo-heritage}
\end{center}
\item L'h�ritage peut se lire dans la javadoc
\item Par d�faut, on h�rite de la classe \java|Object| 
\end{itemize} 
\end{frame}

\subsection{Object}

\begin{frame}{Object}
  Que trouve-t-on dans \java|Object| ? (cf. API)
\medskip
  \begin{itemize}
  \item \java{String toString()}
    \begin{itemize}
    \item Repr�sentation textuelle de (l'�tat de) l'objet
    \item Surtout � des fins de \emph{d�verminage}  
    \item Appel�e implicitement par \java|println|
    \end{itemize}
\medskip
  \item \java{boolean equals(Object o)}
    \begin{itemize}
    \item Compare 2 objets
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Overriding}
Java permet la r��criture (\emph{overriding}) d'une m�thode dans une classe enfant
\begin{itemize}
  \item Le travail fait par la m�thode dans la classe parent ne convient plus dans la classe enfant, je r�cris la m�thode
\end{itemize}
\textbf{Remarque}
\begin{itemize}
  \item � ne pas confondre avec l'\emph{overloading} (la surcharge) d'une m�thode
\end{itemize}
\end{frame}

\subsection{Repr�sentation textuelle}

\begin{frame}[fragile]{Repr�sentation textuelle}
Par d�faut, l'affichage d'un objet est peu clair
\\(utilisation de la version de \java|toString| h�rit�e d'\java|Object|)
\\\bigskip
\emph{Exemple} :
  \begin{itemize}
  \item[]
  \begin{Java}
  Etudiant ada = new Etudiant(33800, "Ada Lovelace");
  System.out.println(ada);
  \end{Java}
  \item[]affiche
  \item[]
  \begin{Java}
  be.heb.esi.java1.Etudiant@19189e
  \end{Java}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Repr�sentation textuelle}
On peut r�crire la m�thode \java|toString|
\\\bigskip
\emph{Exemple} :
\begin{Java}
  public String toString () {
    String res = "(" + nom + ", " + num�ro;
    if (ancien) {
        res = res + ", ancien";
    } else {
        res = res + ", " + ann�e�tude;
        if (doubleur) { 
            res = res + ", doubleur";
        }
    }
    res = res + ")";
    return res;
  }
\end{Java}
\end{frame}

\begin{frame}[fragile]{Repr�sentation textuelle}
L'affichage est � pr�sent plus clair
\\\bigskip
\emph{Exemple} :
  \begin{itemize}
  \item[]
  \begin{Java}
  Etudiant ada = new Etudiant(33800, "Ada Lovelace");
  System.out.println(ada);
  ada.aR�ussi(); 
  System.out.println(ada);
  \end{Java}
  \item[] affiche
  \item[]
  \begin{Java}
  (Ada Lovelace,33800,1)
  (Ada Lovelace,33800,2)
  \end{Java}
  \end{itemize}
\end{frame}

\subsection{La m�thode equals()}

\begin{frame}[fragile]{La m�thode equals()}
Les objets sont des types r�f�rences
\\$\longrightarrow$ l'op�rateur \java|==| teste si c'est le \emph{m�me} objet
\\\bigskip
\emph{Exemple}
\begin{Java}
  Etudiant ada = new Etudiant(33800, "Ada Lovelace");
  Etudiant ada2 = new Etudiant(33800, "Ada Lovelace");
  System.out.println( ada == ada2 );  // false
\end{Java}
\bigskip
La m�thode \java|equals| permet de tester
\begin{itemize}
\item que les 2 objets sont dans le \emph{m�me �tat}  
\item m�me si c'est dupliqu� en m�moire
\end{itemize}
\end{frame}

\begin{frame}{La m�thode equals()}
La m�thode par d�faut dans \java|Object| se contente de comparer les r�f�rences
$\longrightarrow$ besoin de la r�crire
\begin{itemize}
\item Il faut respecter la signature
\item Doit r�pondre \og faux\fg\ si on compare � autre chose qu'un �tudiant (ou \java|null|)
\end{itemize}
\medskip
\emph{Exemple} : Red�finissons l'�galit� pour les �tudiants
\end{frame}

\subsection{Polymorphisme}

\begin{frame}[fragile]{Le polymorphisme}
La signature de la m�thode \java|equals| peut surprendre 
\begin{Java}
  public boolean equals(Object o) { // ...
\end{Java}
\begin{itemize}
\item Elle attend un \java|Object| en param�tre
\item On peut lui passer un \java|Etudiant|
\item C'est gr�ce au polymorphisme
\end{itemize}
\medskip
\emph{Polymorphisme} : L� o� on attend un objet d'une classe \og parent\fg\ on peut donner un objet
d'une classe \og enfant\fg\
\end{frame}

\begin{frame}[fragile]{Le polymorphisme}
Si on peut recevoir n'importe quelle sorte d'objet, comment savoir ce qu'on re�oit vraiment ?
\\\medskip
Gr�ce � l'op�rateur \java|instanceof|
\begin{itemize}
\item Dit si un objet appartient � une classe donn�e \\(ou un de ses enfants)
\item Par d�finition, \java|null| n'est instance de rien
\end{itemize}
\medskip
Notre m�thode \java|equals| devient
\begin{Java}
  public boolean equals(Object o) {
    if ( ! (o instanceof Etudiant) ) return false;
    // ...
\end{Java}
\end{frame}

\begin{frame}{Le polymorphisme}
Le \emph{casting}
\begin{itemize}
\item Nous savons que \java|o| est un �tudiant \\(puisque nous faisons le test juste avant)
\item Le compilateur, lui, ne le sait pas
\item Le compilateur se base sur la d�claration et consid�re \java|o| comme un \java|Object|
\item Il refuserait d�s lors l'appel de m�thodes propres � un \java|Etudiant|
\item Le \emph{casting} \java|(Classe)| demande au compilateur de voir l'objet comme le type enfant
\end{itemize}
\end{frame}

\begin{frame}[fragile]{La m�thode equals()}
Au final, on a
\begin{Java}
  public boolean equals(Object o) {
    if ( ! (o instanceof Etudiant) ) return false;
    Etudiant autre = (Etudiant) o;
    return this.num�ro ==  autre.num�ro 
        && this.nom.equals(autre.nom)
        && this.ann�e�tude == autre.ann�e�tude
        && this.doubleur == autre.doubleur
        && this.ancien == autre.ancien;
  }
\end{Java}
\begin{Java}
  Etudiant ada = new Etudiant(33800, "Ada Lovelace");
  Etudiant ada2 = new Etudiant(33800, "Ada Lovelace");
  System.out.println( ada == ada2 );  // false
  System.out.println( ada.equals(ada2) ); // true
\end{Java}
\end{frame}

\begin{frame}[fragile]{La m�thode equals()}
Pr�cision sur la m�thode \java|equals|
\begin{itemize}
\item Si un attribut sert d'identifiant, on peut comparer seulement celui-l�
\item \emph{Exemple} : un �tudiant est identifi� par son num�ro
(pas 2 �tudiants de m�me num�ro)
\begin{Java}
  public boolean equals(Object o) {
    if ( ! (o instanceof Etudiant) ) return false;
    Etudiant autre = (Etudiant) o;
    return this.num�ro ==  autre.num�ro;
  }
\end{Java}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{La m�thode hashCode()}
La documentation de \java|equals| pr�cise qu'il faut aussi red�finir \java|hashCode|
\begin{itemize}
\item M�thode li�e au \emph{hachage} (sera vu en 2�me)
\item Prenons d�j� la bonne habitude de la red�finir aussi
\item Facilit� par la classe \java|Objects| (� ne pas confondre avec \java|Object|)
\end{itemize}
\medskip
\includegraphics[scale=.5]{../img/java7.jpeg}
\java|Objects| : Classe offrant des m�thodes statiques facilitant la manipulation des objets
\end{frame}

\begin{frame}[fragile]{La m�thode hashCode()}
La m�thode \java|Objects.hash(Object... values)| 
\\cr�e un code � partir des param�tres fournis
\begin{itemize}
\item Si un attribut sert d'identifiant, donner celui-l�
\item Sinon, donner un ensemble d'attributs avec des valeurs fort diff�rentes d'un objet � l'autre
\end{itemize}
\medskip
\emph{Exemple} : Pour un �tudiant
\begin{Java}
  public int hashCode() {
    return Objects.hash(this.num�ro);
  }
\end{Java}
\end{frame}

\begin{frame}[fragile]{Plus sur Objects}
Objects fournit aussi des m�thodes facilitant les tests.
\\\medskip
\emph{Exemple} : Si on doit comparer 2 adresses de personnes mais que l'adresse est un attribut facultatif.
\\\medskip
Ceci n'est pas suffisant
\begin{Java}
  if (adresse1.equals(adresse2)) { //...
\end{Java}
On peut le rendre plus s�r en �crivant
\begin{Java}
  if (   adresse1 == adresse2 // ok si les 2 sont null 
      || adresse1 != null && adresse1.equals(adresse2) ) { //...
\end{Java}
\java|Objects.equals| fait la m�me chose en plus court
\begin{Java}
  if ( Objects.equals(adresse1, adresse2) ) { //...
\end{Java} 
\end{frame}

\begin{frame}[fragile]{Une illustration du polymorphisme}
Revenons un instant sur les exceptions
\begin{itemize}
\item On a vu qu'on peut attraper une exception en g�n�ral
  \begin{Java}
  catch(Exception ex)
  \end{Java}
\item Mais aussi en sp�cifiant exactement l'exception
  \begin{Java}
  catch(IllegalArgumentException ex)
  \end{Java}
\item Comment �a fonctionne ?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Une illustration du polymorphisme}
\begin{itemize}
\item Une exception est un objet
  \begin{Java}
  throw new IllegalArgumentException("L'�ge doit �tre positif !");
  \end{Java}
\item Gr�ce � l'h�ritage et au polymorphisme
  \begin{center}
  \includegraphics[scale=.4]{../img/oo-exception}
  \end{center}
  si on �crit \java|Exception| dans le \java|catch|
  \begin{itemize}
  \item on attrape \java|IllegalArgumentException|
  \item mais aussi d'autres exceptions  $\Longrightarrow$ � �viter
  \end{itemize}
\end{itemize}
\end{frame}

