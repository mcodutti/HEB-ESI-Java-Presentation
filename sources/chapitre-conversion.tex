\section{Les conversions}
\leconwithtoc

\subsection{Présentation}

\begin{frame}[fragile]{Que sait-on déjà ?}
\sigle{Java} est fortement typé; les types doivent correspondre
  \begin{itemize}
  \item Ex: Lors d'une assignation, la valeur doit être du type de la variable
  \end{itemize}
\medskip
Parfois, le compilateur convertit pour nous
  \begin{itemize}
  \item Ex: \java|double d = 1;| (conversion de \java|int| vers \java|double|)
  \end{itemize}
\medskip
Mais souvent ce n'est pas le cas
  \begin{itemize}
  \item Ex: \java|int i = 1.0;| (refusé par le compilateur)
  \end{itemize}
\medskip
Quelles sont les \emph{règles précises} ?
\end{frame}

\begin{frame}[fragile]{Contextes et sortes de conversions}
Il y a \emph{8 groupes} (sortes) de conversions.
\\\medskip
Peuvent être utilisées dans \emph{5 contextes} (éléments de programmes) différents 
\begin{center}
\begin{tabular}{c|c}
 & \emph{8 sortes} \\ \hline
\emph{5 contextes} & en fonction du contexte seulement \\
            & certaines sortes seront permises \\
\end{tabular}
\end{center}
\end{frame}

\subsection{Dans les expressions}
\leconwithtocinside

\begin{frame}[fragile]{Les conversions dans les expressions}
Il existe des conversions implicites dans les expressions
\begin{itemize}
\item Uniquement pour des expressions \emph{numériques}
\item Adapte le type des opérandes à ceux attendus par l'opérateur
\item Conversion la plus fréquente : \\\emph{élargissante de type primitif}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Les conversions dans les expressions}
Conversion élargissante de type primitif
\\(\textit{widening primitive conversion})
\begin{itemize}
\item Vers un type plus général 
\end{itemize}
\begin{small}
\begin{center}
\begin{tabular}{llllll}
\java|byte| & & & & &\\
\hfill$\hookrightarrow$ & \java|short| & & \java|char| & &\\
 & \hfill$\hookrightarrow$ & \java|int| & $\hookleftarrow$ \hfill & &\\
& & \hfill$\hookrightarrow$ & \java|long| & &\\
& &  & \hfill$\hookrightarrow$ & \java|float| &\\
& & & & \hfill$\hookrightarrow$ & \java|double| \\
\end{tabular}
\end{center}
\end{small}
\begin{itemize}
\item entier vers réel : perte de précision possible
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Les conversions dans les expressions}
Cas des opérateurs \emph{binaires}
\begin{itemize}
\item Opérateurs : \java|+|, \java|-|, \java|*|, \java|/|, \java|%|, \java|<|, \java|>|, \java|<=|, \java|>=|, \java|==|, \java|!=|
\item Si opérandes de types différents \\$\Longrightarrow$ on \textit{élargit} le moins large
\item \emph{Exemples}
\begin{Java}
System.out.println( 7 / 2. )   
System.out.println( 7. / 2. )   
System.out.println( 7. + 2 )    
System.out.println( 7.f + 2. )    
System.out.println( 1 <= 1.0 )    
\end{Java} 
\end{itemize} 
\end{frame}

\begin{frame}[fragile]{Les conversions dans les expressions}
Cas des opérateurs \emph{binaires} (suite)
\begin{itemize}
\item On élargit au minimum vers \java|int|
\item Car les opérateurs n'existent pas en dessous
\item \emph{Exemples}
\begin{Java}
short s = 1;
char c = '3';
int i = 4;
... s + i ... 
... s + 5L ... 
... c - s ... 
... 2 * i ... 
... 2 <= i ... 
\end{Java} 
\end{itemize} 
\end{frame}

\begin{frame}[fragile]{Les conversions dans les expressions}
\emph{Cas des opérateurs unaires}
\begin{itemize}
\item Opérateurs : \java|+|, \java|-|
\item Ainsi que l'indice d'un tableau
\item \java|byte|, \java|short|, \java|char| $\longrightarrow$ \java|int|
\item Exemples
\begin{Java}
short s = 1;
byte b = 2;
... +s ... 
... -b ... 
... -'A' ... 
... t[s] ...
... t['1'] ...
\end{Java} 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Les conversions dans les expressions}
Remarque sur \java|++|
\begin{itemize}
\item Existe pour tous les types numériques
\item \emph{Exemple}
\begin{Java}
char c = 'a';
c = c+1; // assignation impossible
\end{Java} 
ne se comporte pas comme 
\begin{Java}
char c = 'a';
c++;    //  c vaut 'b'
\end{Java} 
\end{itemize} 
\end{frame}

\subsection{Lors d'une assignation (et d'un return)}
\leconwithtocinside

\begin{frame}[fragile]{Conversion lors d'une assignation}
Que se passe-t-il lors d'une \emph{assignation} ?
\begin{itemize}
\item Adapte le type de l'expression au type de la variable
\item Opérateurs : \java|=|, \java|+=|, \java|-=|, \java|*=|, \java|/=|, \java|%=|
\item Permet la \emph{conversion élargissante} déjà vue
\item Mais aussi la \emph{conversion arrondissante} 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Conversion lors d'une assignation}
Conversion arrondissante de type primitif
\\(\textit{narrowing primitive conversion})
\begin{center}
\begin{itemize}
\item schéma général
\begin{tabular}{lllllll}
\java|double| & & & & & &\\
\hfill$\hookrightarrow$ & \java|float| & & & & &\\
 & \hfill$\hookrightarrow$ & \java|long| & & & &\\
& & \hfill$\hookrightarrow$ & \java|int| & & & \\
& & & \hfill$\hookrightarrow$ & \java|short| & $\longleftrightarrow$ & \java|char|\\
& & & & \hfill$\hookrightarrow$ & \java|byte| & $\swarrow\nearrow$ \\
\end{tabular}
\item \`A chaque étape : \emph{perte de précision} possible
\end{itemize}
\end{center}
\end{frame}

\begin{frame}[fragile]{Conversion lors d'une assignation}
Dans le cadre d'une assignation
\begin{itemize}
\item Elles ne sont pas toutes permises
\item \emph{si et seulement si}
\begin{itemize}
\item La variable est de type \java|byte|, \java|short|, ou \java|char|
\item L'expression est 
\begin{itemize}
\item constante 
\item de type \java|byte|, \java|short|, \java|char| ou \java|int|
\item sa valeur est représentable dans le type de la variable
\end{itemize}
\end{itemize}
\end{itemize}
\medskip
Si ce n'est pas le cas, erreur à la compilation
\end{frame}

\begin{frame}[fragile]{Conversion lors d'une assignation}
\emph{Exercice} : identifiez les instructions correctes
\begin{Java}
long l1 = 12; 
long l2 = 'a'+1; 
short s1 = 12; 
short s2 = 1+2; 
byte b1 = 123245; 
byte b2 = s1+1; 
byte b3 = 21L; 
\end{Java}
\begin{Java}
char a ='a';
a += 1;
a = a+1; 
\end{Java}
\end{frame}

\begin{frame}[fragile]{Conversion de la valeur de retour}
Situation similaire pour la \emph{valeur de retour} d'une méthode
\begin{itemize}
\item Le type de l'expression accompagnant l'instruction \java|return| doit pouvoir être ramené au \nterm{ResultType}
\item Assimilable à une assignation $\Longrightarrow$ mêmes règles
\item \emph{Exemple}
\begin{Java}
public static long add( int opérandeGauche, int opérandeDroite) {
    return opérandeGauche + opérandeDroite;
}
\end{Java} 
\end{itemize} 
\end{frame}

\subsection{Lors d'un appel de méthode}
\leconwithtocinside

\begin{frame}[fragile]{Conversion lors d'un appel de méthode}
Conversion des \emph{paramètres} effectifs
\begin{itemize}
\item \emph{Conversion élargissante} possible
\item \emph{Exemple} : avec la méthode suivante
\begin{Java}
public static int add( int opérandeGauche, int opérandeDroite) {
    return opérandeGauche + opérandeDroite;
}
\end{Java}
les arguments lors de l'appel peuvent être \java|byte|, \java|short|, \java|char| ou encore \java|int|
\end{itemize} 
\end{frame}

\begin{frame}[fragile]{Conversion lors d'un appel de méthode}
Difficulté liée à la \emph{surcharge}
\begin{itemize}
\item S'il existe plusieurs méthodes avec le même nom, il peut y avoir plusieurs candidates pour un appel
\item \emph{Exemple}
\begin{Java}
public static int max(long op1, long op2) {...}
public static int max(int op1, int op2) {...}
\end{Java}
Quelle méthode est choisie avec cet appel ?
\begin{Java}
short s1=1, s2=2;
max(s1,s2);
\end{Java}
\end{itemize} 
\end{frame}

\begin{frame}[fragile]{Conversion lors d'un appel de méthode}
\emph{Exemple}
\begin{Java}
public static double op( double opérandeGauche, double opérandeDroite) {
    return opérandeGauche * opérandeDroite;
}

public static int op( int opérandeGauche, int opérandeDroite) {
    return opérandeGauche / opérandeDroite;
}
\end{Java}
\begin{itemize}
\item Que retourne \java|op(3.,2.)| ?
\item Que retourne \java|op(3,2)| ?
\item Que retourne \java|op(3.,2)| ?
\end{itemize} 
\end{frame}

\begin{frame}[fragile]{Conversion lors d'un appel de méthode}
Cas particulier
\begin{itemize}
\item Parfois, il n'y a pas de méthode plus spécifique. 
\item \emph{Exemple}
\begin{Java}
public static int max( int op1, long op2 ) {...}
public static int max( long op1, int op2 ) {...}
\end{Java}
Accepté mais certains appels seront ambigus
\\(erreur à la compilation)
\begin{itemize}
\item \java|max(1,2L)| // 1ère méthode
\item \java|max(1L,2)| // 2ème méthode
\item \java|max(1,2)|  // ambigu
\end{itemize}
\end{itemize} 
\end{frame}

\subsection{Avec les chaines de caractères}
\leconwithtocinside

\begin{frame}[fragile]{Conversion en chaines de caractères}
Opérateur \java|+| avec un opérande de type \java|String|
\\$\Rightarrow$ l'autre opérande converti en \java|String|
\begin{itemize}
\item \emph{Exemples}
\begin{Java}
System.out.println("1+1 = "+2);
String s = "Pi = " + 3.1415;
\end{Java}
\item Que donnera ceci ?
\begin{Java}
System.out.println("1"+2+3);
System.out.println(1+2+"3");
\end{Java}
\end{itemize}
\end{frame}

\subsection{Boxing et unboxing}
\leconwithtocinside

\begin{frame}[fragile]{Les wrappers}
\`A chaque type primitif correspond une classe \emph{englobante} (\emph{wrapper})

{\small
\begin{center}
\begin{tabular}{rcl|rcl}
\java|boolean| & : & \code|Boolean|   & \java|int|    & : & \code|Integer| \\
\java|byte|    & : & \code|Byte|      & \java|long|   & : & \code|Long| \\
\java|char|    & : & \code|Character| & \java|float|  & : & \code|Float| \\
\java|short|   & : & \code|Short|     & \java|double| & : & \code|Double| \\
\end{tabular}
\end{center}
}

\begin{itemize}
\item Objet avec la même valeur que la valeur primitive 
\item Utile là o\`u un objet est requis
\item \emph{Exemple}
\begin{Java}
  List<Integer> list = new ArrayList<Integer>();
\end{Java}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Boxing / unboxing}
Conversions automatiques
\begin{itemize}
\item Du primitif vers le wrapper (\emph{boxing})
\item Du wrapper vers le primitif (\emph{unboxing})
\item Ajoutées par le compilateur
  \begin{itemize}
  \item Dans les expressions
  \item Dans les assignations
  \item Avec les paramètres effectifs
  \end{itemize}
\item \emph{Exemple} : repérez les (un)boxing implicites
\begin{Java}
List<Integer> list = new ArrayList<Integer>();
list.add(1);
System.out.println(list.get(0)+1);
list.set(0, list.get(0)+1 );
int i = list.get(0);
\end{Java}
\end{itemize}
\end{frame}

\subsection{Le casting}
\leconwithtocinside

\begin{frame}[fragile]{Le \textit{casting}}
On peut imposer une conversion que le compilateur ne ferait pas.
\begin{itemize}
\item C'est la \emph{conversion explicite}
\item Valeur convertie dans le type explicité par le casting
\begin{grammaire}
\nterm{Casting} :
  \term{(} \nterm{Type} \term{)} \nterm{Expression}
\end{grammaire}
\item Grammaticalement, c'est assimilé à un opérateur
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tableau des priorités et associativités}
\begin{center}
\begin{small}
\begin{tabular}{c|r|l|c}
priorité & & & associativité \\ \hline
forte & post unaires & \java|(params)|, \java|.|, \java|expr++|, \java|expr--| & $\Longrightarrow$ \\ 
       & pré unaires & \java|(Type)|, \java|++expr|, \java|--expr|,  &  \\
       &             & \java|-|, \java|+|, \java|!|, \java|new| & $\Longleftarrow$ \\
       & multiplicatif & \java|*|, \java|/|, \java|%| & $\Longrightarrow$  \\
       & additif & \java|-|, \java|+|  & $\Longrightarrow$ \\
       & relationnels & \java|<|, \java|>|, \java|<=|, \java|>=| & $\Longrightarrow$  \\
       & égalité & \java|==|, \java|!=| & $\Longrightarrow$  \\
       & et & \java|&&| & $\Longrightarrow$  \\
       & ou & {\color{bleu} \verb,||,} & $\Longrightarrow$  \\
       & condition & \java|:?| & $\Longleftarrow$  \\
faible  & assignations & \java|=|, \java|+=|, \java|-=|, \java|*=|, \java|/=|, \java|%=| & $\Longleftarrow$   \\
\end{tabular}
\end{small}
\end{center}
\end{frame}

\begin{frame}{Le \textit{casting}}
Quelles sont les conversions permises ?
\begin{itemize}
\item \emph{élargissante}
\item \emph{arrondissante}
\item \emph{(un)boxing}
\item \emph{identique}
  \begin{itemize}
  \item conversion dans le type que possède déjà l'expression 
  \item par facilité (si on n'est pas sûr) 
  \item permise aussi dans les autres contextes car simplifie les règles
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Le \textit{casting}}
Remarques sur les conversions \emph{arrondisantes}
\begin{itemize}
\item aucune contrainte
\item si d'un type entier vers un autre type entier 
  \begin{itemize}
  \item on prend les octets de poids faible
  \item $\Longrightarrow$ valeur convertie peut être fort différente
  \end{itemize}
\item \emph{Exemple} : \java{byte b = (byte) 256;}
\end{itemize}
\medskip
\begin{center}
256 = 
\begin{tabular}{|c|c|c|c|}
\hline
0 & 0 & 0 \dots 0 1 & 0 \\
\hline
\end{tabular}
$\Longrightarrow$ b = 
\begin{tabular}{|c|}
\hline
0 \\
\hline
\end{tabular}
= 0
\end{center}
\end{frame}

\begin{frame}[fragile]{Le \textit{casting}}
Ne \emph{peut pas} être utilisé pour
\medskip
\begin{itemize}
\item Convertir en chaîne
  \begin{itemize}
  \item \java|(String) monEntier| \emph{interdit}
  \item Écrire \java|""+monEntier| à la place
  \end{itemize}
\medskip
\item Convertir une chaîne qui contient un numérique
  \begin{itemize}
  \item \java|(int) "12"| \emph{interdit}
  \item Écrire \java|Integer.parseInt("12")| à la place
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exemples de \textit{casting}}
\begin{Java}
int entier = (int) 5; 
int entier = (int) 5l; 
int entier = (int) 12000000000000000000000l; 
    // erreur à la compilation ...
int entier = (int) 1200000000000L;  // Accepté mais...
double réel = (double) 12; 
String mot = (String) 12; // erreur à la compilation 
int entier = (int) "12";  // erreur à la compilation 
String mot = (String) "mot"; 
boolean b = (boolean) 1;  // erreur à la compilation 
int entier = (byte) 500-400;   
byte entier = (byte) 500-400; // erreur à la compilation
byte entier = (byte) (500-400);
int entier = (byte) (190-(byte)100);
\end{Java}
\end{frame}

\subsection{Récapitulatif}

\begin{frame}{Récapitulatif}
Il y a \emph{8 sortes} de conversions
\begin{itemize}
\item Élargissante / arrondissante de type primitif
\item Conversion en chaine de caractères
\item Boxing / Unboxing
\item Conversion identique
\item Élargissante / arrondissante de type référence
\\On n'insiste pas sur celles-ci mais on peut en retrouver une illustration dans les méthodes \java|equals|
\end{itemize}
\end{frame}

\begin{frame}{Récapitulatif}
Il y a \emph{5 contextes} de conversion
\begin{itemize}
\item La promotion (calcul) numérique
\item L'assignation
\item Le casting
\item La chaine de caractères
\item L'appel de méthode
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Récapitulatif}
\begin{scriptsize}
\begin{center}
\begin{tabular}{r|cccccc}
 & élargis. & arrondi & chaine & boxing & unboxing & ident. \\ \hline
promotion num. & $\surd$& & & & $\surd$ & $\surd$ \\
assignation & $\surd$ & $\surd$ (*) &  & $\surd$& $\surd$ & $\surd$ \\
chaine & & & $\surd$  & && $\surd$ \\
casting & $\surd$ & $\surd$ &  &  $\surd$& $\surd$& $\surd$ \\ 
méthode & $\surd$ & &  &  $\surd$& $\surd$& $\surd$ \\
\hline
\end{tabular}
\end{center}
\bigskip
(*) : sous certaines conditions
\end{scriptsize}
\end{frame}  



